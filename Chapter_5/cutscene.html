<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Cutscene Final - Capítulo 3</title>
<style>
body { margin: 0; background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
canvas { max-width: 100%; max-height: 100%; object-fit: contain; background: #111; }
</style>
</head>
<body>

<canvas id="gameCanvas" width="800" height="450"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// Configurações de Câmera
let cameraZoom = 1.3; // Ajuste aqui: 1.0 é normal, 1.5 é bem perto
let offsetY = 50;     // Ajuste para descer a câmera e focar no chão (zoom foca no centro)

// ==================================================
// CARREGAMENTO DE IMAGENS
// ==================================================
const images = {};
const imageSources = {
    bg: "assets/Battleground/casa/fundo.png",
    ground: "assets/Battleground/Ground.png",
    mesa: "assets/Battleground/casa/mesa.png",
    cadeira: "assets/Battleground/casa/cadeira.png",
    bottle: "assets/Battleground/casa/Bottle.png",
    pao: "assets/Battleground/casa/pao.png",
    lantern: "assets/Battleground/casa/Street_Lantern.png",
    casa3: "assets/Battleground/casa/casa3.png"
};

let imagesLoaded = 0;
const totalImages = Object.keys(imageSources).length;

for (let key in imageSources) {
    images[key] = new Image();
    images[key].src = imageSources[key];
    images[key].onload = () => { imagesLoaded++; };
}

const houses = [
    { x: -50, y: 55, w: 250, h: 200, type: 'casa3' },
    { x: 300, y: 220, w: 50, h: 30, type: 'cadeira' },
    { x: 350, y: 220, w: 100, h: 30, type: 'mesa' },
    { x: 375, y: 220, w: 50, h: 30, type: 'cadeira' },
    { x: 450, y: 220, w: 50, h: 30, type: 'cadeira' },
    { x: 390, y: 195, w: 30, h: 30, type: 'bottle' },
    { x: 375, y: 195, w: 30, h: 30, type: 'pao' },
    { x: 425, y: 100, w: 120, h: 170, type: 'lantern' },
    { x: 600, y: 55, w: 250, h: 200, type: 'casa3' },
];

// ==================================================
// LÓGICA DE SPRITES
// ==================================================
function createSprite(src, frameCount, frameSpeed) {
    const img = new Image();
    img.src = src;
    return { img, frameCount, frameSpeed, frameIndex: 0, timer: 0 };
}

function updateSprite(sprite) {
    sprite.timer++;
    if (sprite.timer >= sprite.frameSpeed) {
        sprite.timer = 0;
        sprite.frameIndex = (sprite.frameIndex + 1) % sprite.frameCount;
    }
}

function drawSprite(sprite, x, y, w, h, facing = "right") {
    if (!sprite.img.complete) return;
    const fw = sprite.img.width / sprite.frameCount;
    const fh = sprite.img.height;
    ctx.save();
    if (facing === "left") {
        ctx.translate(x + w, y);
        ctx.scale(-1, 1);
        ctx.drawImage(sprite.img, fw * sprite.frameIndex, 0, fw, fh, 0, 0, w, h);
    } else {
        ctx.drawImage(sprite.img, fw * sprite.frameIndex, 0, fw, fh, x, y, w, h);
    }
    ctx.restore();
}

// ==================================================
// PERSONAGENS
// ==================================================
const escolhaMenu = localStorage.getItem('heroi_da_jornada') || 'loiro'; 
const heroiPadrao = (escolhaMenu === 'castanha') ? 'Knight' : 'Swordsman';

const player = { x: 270, y: 0, w: 100, h: 100, vy: 0, facing: "right", sprite: createSprite(`assets/${heroiPadrao}/Idle.png`, (heroiPadrao === 'Knight' ? 6 : 8), 12) };
const enchantressNPC = { x: 210, y: 0, w: 100, h: 100, vy: 0, facing: "right", sprite: createSprite("assets/Enchantress/Idle.png", 5, 14) };
const wizardNPC = { x: 240, y: 0, w: 100, h: 100, vy: 0, facing: "right", sprite: createSprite("assets/Wizard/Idle.png", 6, 14) };
const farmerNPC = { x: 350, y: 0, w: 75, h: 100, vy: 0, facing: "right", sprite: createSprite("assets/Farmer/Idle.png", 4, 15) };
const warrior_1NPC = { x: 400, y: 0, w: 100, h: 100, vy: 0, facing: "right", sprite: createSprite("assets/Warrior_1/Idle.png", 6, 12) };
const warrior_2NPC = { x: 450, y: 0, w: 100, h: 100, vy: 0, facing: "left", sprite: createSprite("assets/Warrior_2/Idle.png", 5, 12) };
const warrior_3NPC = { x: 500, y: 0, w: 100, h: 100, vy: 0, facing: "left", sprite: createSprite("assets/Warrior_3/Idle.png", 5, 12) };

const entities = [player, enchantressNPC, wizardNPC, farmerNPC, warrior_1NPC, warrior_2NPC, warrior_3NPC];

// ==================================================
// ESTADOS E DIÁLOGOS
// ==================================================
const gravity = 0.8;
const platforms = [{ x: 0, y: 250, w: canvas.width, h: 150 }];
let gameState = "dialogue"; 
let dialogueIndex = 0;
let fadeAlpha = 0;

const chapter3Dialogue = [
    { speaker: "Wizard", text: "Então… era um dragão que estava me influenciando…" },
    { speaker: "Wizard", text: "A mim e à Enchantress…" },
    { speaker: "Líder Anão Sem Camisa", text: "Foi o dragão que havia espantado os orcs para perto das montanhas." },
    { speaker: "Líder Anão Vermelho", text: "Mas não pode ter sido o dragão o responsável por aquele arqueiro..." },
    { speaker: "Líder Anão Amarelo", text: "Nós curamos as feridas do arqueiro, mas ele não quer contar." },
    { speaker: "Líder Anão Amarelo", text: "Em breve, um de nós irá se tornar Rei e protegerá o reino." },
    { speaker: "Narrador", text: "Você vê todos comemorando ao redor da mesa." },
    { speaker: "Narrador", text: "O dragão foi derrotado… mas nem todas as sombras sumiram." }
];

function nextDialogue() {
    if (dialogueIndex < chapter3Dialogue.length - 1) dialogueIndex++;
    else gameState = "fadeOut";
}

window.addEventListener("keydown", e => { if (gameState === "dialogue" && (e.key === "Enter" || e.key === " ")) nextDialogue(); });
canvas.addEventListener("touchstart", e => { e.preventDefault(); if (gameState === "dialogue") nextDialogue(); });

// ==================================================
// LOOP PRINCIPAL
// ==================================================
function update() {
    entities.forEach(e => {
        updateSprite(e.sprite);
        e.vy += gravity;
        e.y += e.vy;
        platforms.forEach(p => {
            if (e.x < p.x + p.w && e.x + e.w > p.x && e.y + e.h > p.y && e.y + e.h < p.y + p.h && e.vy >= 0) {
                e.y = p.y - e.h;
                e.vy = 0;
            }
        });
    });

    if (gameState === "fadeOut") {
        fadeAlpha += 0.02;
        if (fadeAlpha >= 1) window.location.href = "../index.html";
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Início do Zoom
    ctx.save(); 
    ctx.translate(canvas.width / 2, (canvas.height / 2) + offsetY); 
    ctx.scale(cameraZoom, cameraZoom);
    ctx.translate(-canvas.width / 2, -canvas.height / 2);

    // 1. Fundo
    if (images.bg && images.bg.complete) ctx.drawImage(images.bg, 0, 0, canvas.width, canvas.height);
    
    // 2. Chão
    if (images.ground && images.ground.complete) {
        platforms.forEach(p => {
            for (let x = p.x; x < p.x + p.w; x += 64) ctx.drawImage(images.ground, x, p.y, 64, p.h);
        });
    }

    // 3. Casas e Objetos
    houses.forEach(h => {
        const img = images[h.type];
        if (img && img.complete) ctx.drawImage(img, h.x, h.y, h.w, h.h);
    });

    // 4. Personagens
    entities.forEach(e => drawSprite(e.sprite, e.x, e.y, e.w, e.h, e.facing));

    ctx.restore(); // Fim do Zoom

    // 5. Interface (UI não sofre zoom)
    if (gameState === "dialogue") {
        const d = chapter3Dialogue[dialogueIndex];
        ctx.fillStyle = "rgba(0,0,0,0.85)";
        ctx.fillRect(40, 320, 720, 100);
        ctx.fillStyle = "#FFD700";
        ctx.font = "bold 20px Arial";
        ctx.fillText(d.speaker, 60, 350);
        ctx.fillStyle = "#FFF";
        ctx.font = "18px Arial";
        ctx.fillText(d.text, 60, 385);
    }

    if (gameState === "fadeOut") {
        ctx.fillStyle = `rgba(0,0,0,${fadeAlpha})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    
    requestAnimationFrame(draw);
}

// Inicia os loops
setInterval(update, 1000/60);
draw();
</script>
</body>

</html>

